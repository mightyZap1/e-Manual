import{_ as u,C as n,c as s,o as b,a2 as i,j as d,G as e,w as l,a as r}from"./chunks/framework.DSqgMOff.js";const h="/assets/packetDescription.C0Eykc0N.png",m=JSON.parse('{"title":"12Lf ModbusRTU","description":"","frontmatter":{"slug":"12Lf_ModbusRTU.md","title":"12Lf ModbusRTU","modified":null,"version":null},"headers":[],"relativePath":"actuator/Mini12Lf/Manual/12Lf_ModbusRTU.md","filePath":"actuator/Mini12Lf/Manual/12Lf_ModbusRTU.md","lastUpdated":1755579996000}'),f={name:"actuator/Mini12Lf/Manual/12Lf_ModbusRTU.md"};function y(p,t,x,g,R,C){const a=n("center"),o=n("font");return b(),s("div",null,[t[34]||(t[34]=i('<h1 id="_12lf-modbusrtu-manaual" tabindex="-1">12Lf ModbusRTU Manaual <a class="header-anchor" href="#_12lf-modbusrtu-manaual" aria-label="Permalink to &quot;12Lf ModbusRTU Manaual&quot;">​</a></h1><h2 id="_1-개요" tabindex="-1">1 개요 <a class="header-anchor" href="#_1-개요" aria-label="Permalink to &quot;1 개요&quot;">​</a></h2><p>MODBUS 프로토콜은 산업용 프로토콜로 PLC통신 등에 주로 사용되는 표준이 되는 프로토콜입니다. 주로 사용하는 방식은 RTU방식과 ASCII방식이 주로 사용되고, 요즘에는 TCP방식도 나와있습니다.</p><p>1979년부터 업계의 사실상 직렬 표준인 MODBUS는 수 백만 개의 자동화 장치가 지속적으로 통신할 수 있도록 지원하고 있습니다. MODBUS는 요청/응답 프로토콜이며 기능 코드별로 지정된 서비스를 제공합니다. 프레임의 구성은 Application Data Unit인 ADU와 Protocol Data Unit인 PDU로 구성되어 있습니다.</p><h2 id="_2-프레임-구조" tabindex="-1">2 프레임 구조 <a class="header-anchor" href="#_2-프레임-구조" aria-label="Permalink to &quot;2 프레임 구조&quot;">​</a></h2><h3 id="_2-1-packet-discription" tabindex="-1">2.1 Packet Discription <a class="header-anchor" href="#_2-1-packet-discription" aria-label="Permalink to &quot;2.1 Packet Discription&quot;">​</a></h3><p>mightyZAP은 MODBUS-RTU 프로토콜 내용을 준수합니다.<br> 본 매뉴얼에 나오지 않은 사항들은 아래의 관련 표준 문서를 참조하여 주시기 바랍니다.</p><h4 id="_2-1-1-packet-structure" tabindex="-1">2.1.1 Packet Structure <a class="header-anchor" href="#_2-1-1-packet-structure" aria-label="Permalink to &quot;2.1.1 Packet Structure&quot;">​</a></h4><p>MODBUS-RTU 프로토콜의 최대 송수신 패킷 길이는 256 Byte 입니다. 따라서 송수신 패킷의 총 길이가 256Byte 를 넘기지 않도록 주의하여 주십시오.<br> MODBUS-RTU 통신 Mode 는 Packet 을 구분하기 위해서 아래 그림과 같이 시작과 끝 사이에 최소 3.5 Char 이상의 이 필요합니다.</p><p><img src="'+h+'" alt="packet Description"></p><ul><li>송신 패킷 구조</li></ul>',11)),d("table",null,[t[15]||(t[15]=d("thead",null,[d("tr",null,[d("th"),d("th",null,"Additional Address"),d("th",null,"Fucntion code"),d("th",{colspan:"3"},"Data"),d("th",null,"Error Check"),d("th")])],-1)),d("tbody",null,[d("tr",null,[t[2]||(t[2]=d("td",{rowspan:"2"},"byte",-1)),t[3]||(t[3]=d("td",null,"0",-1)),t[4]||(t[4]=d("td",null,"1",-1)),t[5]||(t[5]=d("td",null,"2",-1)),d("td",null,[e(a,null,{default:l(()=>t[0]||(t[0]=[r("…")])),_:1,__:[0]})]),d("td",null,[e(a,null,{default:l(()=>t[1]||(t[1]=[r("…")])),_:1,__:[1]})]),t[6]||(t[6]=d("td",null,"n-1",-1)),t[7]||(t[7]=d("td",null,"n",-1))]),d("tr",null,[t[10]||(t[10]=d("td",null,"mightyZAP ID",-1)),t[11]||(t[11]=d("td",null,"Function",-1)),t[12]||(t[12]=d("td",null,"Data",-1)),d("td",null,[e(a,null,{default:l(()=>t[8]||(t[8]=[r("…")])),_:1,__:[8]})]),d("td",null,[e(a,null,{default:l(()=>t[9]||(t[9]=[r("…")])),_:1,__:[9]})]),t[13]||(t[13]=d("td",null,"CRC(MSB)",-1)),t[14]||(t[14]=d("td",null,"CRC(LSB)",-1))])])]),t[35]||(t[35]=d("ul",null,[d("li",null,[r("수신 패킷 구조"),d("br"),r(" [정상 응답]")])],-1)),d("table",null,[t[31]||(t[31]=d("thead",null,[d("tr",null,[d("th"),d("th",null,"Additional Address"),d("th",null,"Fucntion code"),d("th",{colspan:"3"},"Data"),d("th",{colspan:"2"},"Error Check")])],-1)),d("tbody",null,[d("tr",null,[t[18]||(t[18]=d("td",{rowspan:"2"},"byte",-1)),t[19]||(t[19]=d("td",null,"0",-1)),t[20]||(t[20]=d("td",null,"1",-1)),t[21]||(t[21]=d("td",null,"2",-1)),d("td",null,[e(a,null,{default:l(()=>t[16]||(t[16]=[r("…")])),_:1,__:[16]})]),d("td",null,[e(a,null,{default:l(()=>t[17]||(t[17]=[r("…")])),_:1,__:[17]})]),t[22]||(t[22]=d("td",null,"n-1",-1)),t[23]||(t[23]=d("td",null,"n",-1))]),d("tr",null,[t[26]||(t[26]=d("td",null,"mightyZAP ID",-1)),t[27]||(t[27]=d("td",null,"Function",-1)),t[28]||(t[28]=d("td",null,"Data",-1)),d("td",null,[e(a,null,{default:l(()=>t[24]||(t[24]=[r("…")])),_:1,__:[24]})]),d("td",null,[e(a,null,{default:l(()=>t[25]||(t[25]=[r("…")])),_:1,__:[25]})]),t[29]||(t[29]=d("td",null,"CRC(MSB)",-1)),t[30]||(t[30]=d("td",null,"CRC(LSB)",-1))])])]),t[36]||(t[36]=i(`<pre><code>[비 정상 응답답]
</code></pre><table><thead><tr><th></th><th>Additional Address</th><th>Fucntion code</th><th>Data</th><th>Error Check</th><th></th></tr></thead><tbody><tr><td rowspan="2">byte</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td></tr><tr><td>mightyZAP ID</td><td>Function <br>+ 0x80</td><td>Exception code</td><td>CRC(MSB)</td><td>CRC(LSB)</td></tr></tbody></table><h4 id="_1-1-2-packet-element-설명" tabindex="-1">1.1.2 Packet Element 설명 <a class="header-anchor" href="#_1-1-2-packet-element-설명" aria-label="Permalink to &quot;1.1.2 Packet Element 설명&quot;">​</a></h4>`,3)),e(o,{color:"#3f93ff"},{default:l(()=>t[32]||(t[32]=[d("b",null,"Node ID",-1)])),_:1,__:[32]}),t[37]||(t[37]=d("ul",null,[d("li",null,"mightyZAP의 IDF로 다중 연결 방식으로 Daisy Chain 연결 지원을 위한 식별자 입니다."),d("li",null,"ID가 '0'일 경우 Broadcasting ID로 동작합니다.")],-1)),e(o,{color:"#3f93ff"},{default:l(()=>t[33]||(t[33]=[d("b",null,"Function Code",-1)])),_:1,__:[33]}),t[38]||(t[38]=i('<ul><li>mightyZAP에서 지원하는 Modbus-RTU 표준 Function code는 다음과 같습니다.</li></ul><table><thead><tr><th>Function</th><th>Code</th><th>Description</th></tr></thead><tbody><tr><td>Read Holding Register</td><td>0x03</td><td>mightyZAP의 Data를 읽어오기</td></tr><tr><td>Write Single Register</td><td>0x06</td><td>mightyZAP의 특정 주소에 Data값을 Setting 하기</td></tr><tr><td>Write Multiple Register</td><td>0x10</td><td>mightyZAP의 연속된 주소에 Data값을 Setting 하기</td></tr><tr><td>SP Function code</td><td>0xxx</td><td>해당 모델 사용자 매뉴얼을 참조하여주시기 바랍니다.</td></tr></tbody></table><ul><li><strong>Data</strong> 송신 : Read Register 명령의 경우 Modbus 주소, 레지스터 개수, Byte 개수 등을 지정하게 되며, Write Register 명령의 경우 Modbus 주소, Byte 개수, 설정 할 값 등을 지정하게 됩니다.</li><li><strong>Data</strong> 수신: Read Register 명령의 경우, 정상응답은 Node ID 와 Function Code 가 송신 때와 동일한 값으로 수신되며, Data 는 송신 때 보낸 Register 순서에 따라 각 Register 의 값이 수신됩니다.</li></ul><p>Write Single Register 명령의 경우, 송신 때와 동일한 데이터가 수신됩니다. Write Multi Register 의 경우에는 Write Multi Register 명령으로 데이터를 쓰고자 한 Register 의 시작 주소와 Register 개수가 수신됩니다.</p><p>이상응답의 경우에는 Node ID, Error Code, Exception Code 로 구성되며, 이상응답의 패킷 구조는 Function Code 와 관계없이 모두 동일합니다.</p><ul><li><p>CRC 16 비트 CRC 값을 입력합니다. 구성은 MSB/LSB 로 나누어 각각 1Byte 씩 전송합니다.</p></li><li><p>Exception Code mightyZAP에서 지원하는 모든 Function Code 의 이상 응답에 대한 Exception Code 는 아래와 같이 정의되어 있습니다.</p></li></ul><table><thead><tr><th>Exception Code</th><th></th><th>Description</th></tr></thead><tbody><tr><td>0x01</td><td>Illegal Function</td><td>지원하지 않는 Function Code</td></tr><tr><td>0x02</td><td>Illegal Data Address</td><td>잘못된 레지스터 주소</td></tr><tr><td>0x03</td><td>Illegal Data Value</td><td>잘못된 데이터 값</td></tr><tr><td>0x04</td><td>Slave Device Failure</td><td>장치 고장, 파라미터 설정값 이상(ready)</td></tr><tr><td>0x05</td><td>Acknowledge</td><td>데이터가 준비되지 않은 상태(ready)</td></tr><tr><td>0x06</td><td>Slave Device Busy</td><td>파라미터 잠금 상태</td></tr></tbody></table><h3 id="프로토콜-function-code-설명" tabindex="-1">프로토콜 Function Code 설명 <a class="header-anchor" href="#프로토콜-function-code-설명" aria-label="Permalink to &quot;프로토콜 Function Code 설명&quot;">​</a></h3><h4 id="read-holding-register" tabindex="-1">Read Holding Register <a class="header-anchor" href="#read-holding-register" aria-label="Permalink to &quot;Read Holding Register&quot;">​</a></h4><p>단일 레지스터(16bit 데이터) 및 연속된 레지스터 블록(16bit 데이터 단위)의 값을 읽습니다.</p><ul><li>Request</li></ul><table><thead><tr><th></th><th>byte</th><th>Data</th></tr></thead><tbody><tr><td>Function Code</td><td>1 byte</td><td>0x03</td></tr><tr><td>Starting Addresse</td><td>2 byte</td><td>0x0000 to 0xffff</td></tr><tr><td>Quatity of Register</td><td>2 bytes</td><td>1 to 125(0x7d)</td></tr></tbody></table><ul><li>Request OK</li></ul><table><thead><tr><th></th><th>byte</th><th>Data</th></tr></thead><tbody><tr><td>Function Code</td><td>1 byte</td><td>0x03</td></tr><tr><td>Starting Addresse</td><td>2 byte</td><td>2 x N*</td></tr><tr><td>Quatity of Register</td><td>N* x 2 bytes</td><td></td></tr><tr><td>*N = Quantity of Registers</td><td></td><td></td></tr></tbody></table><ul><li>Request not OK</li></ul><table><thead><tr><th></th><th>byte</th><th>Data</th></tr></thead><tbody><tr><td>Error Code</td><td>1 byte</td><td>0x83</td></tr><tr><td>Exception Code</td><td>1 byte</td><td>0x01 ~ 0x06</td></tr></tbody></table><ul><li>example</li></ul><h4 id="write-sing-register" tabindex="-1">Write Sing Register <a class="header-anchor" href="#write-sing-register" aria-label="Permalink to &quot;Write Sing Register&quot;">​</a></h4><p>단일레지스터(16bit 데이터)에 값을 씁니다.</p><ul><li>Request</li></ul><table><thead><tr><th></th><th>byte</th><th>Data</th></tr></thead><tbody><tr><td>Function Code</td><td>1 byte</td><td>0x06</td></tr><tr><td>Starting Addresse</td><td>2 bytes</td><td>0x0000 to 0xffff</td></tr><tr><td>Quatity of Register</td><td>2 bytes</td><td>0x0000 to 0xffff</td></tr></tbody></table><ul><li>Request OK</li></ul><table><thead><tr><th></th><th>byte</th><th>Data</th></tr></thead><tbody><tr><td>Function Code</td><td>1 byte</td><td>0x03</td></tr><tr><td>Starting Addresse</td><td>2 bytes</td><td>0x0000 to 0xffff</td></tr><tr><td>Quatity of Register</td><td>2 bytes</td><td>0x0000 to 0xffff</td></tr><tr><td>*N = Quantity of Registers</td><td></td><td></td></tr></tbody></table><ul><li>Request not OK</li></ul><table><thead><tr><th></th><th>byte</th><th>Data</th></tr></thead><tbody><tr><td>Error Code</td><td>1 byte</td><td>0x86</td></tr><tr><td>Exception Code</td><td>1 byte</td><td>0x01 ~ 0x06</td></tr></tbody></table><ul><li>example</li></ul><h4 id="write-multi-register-0x10" tabindex="-1">Write Multi Register(0x10) <a class="header-anchor" href="#write-multi-register-0x10" aria-label="Permalink to &quot;Write Multi Register(0x10)&quot;">​</a></h4><p>연속된 레지스터 블록(16bit 데이터 단위)에 값을 씁니다.</p><ul><li>Request</li></ul><table><thead><tr><th></th><th>byte</th><th>Data</th></tr></thead><tbody><tr><td>Function Code</td><td>1 byte</td><td>0x06</td></tr><tr><td>Starting Addresse</td><td>2 bytes</td><td>0x0000 to 0xffff</td></tr><tr><td>Quatity of Register</td><td>2 bytes</td><td>0x0000 to 0xffff</td></tr><tr><td>Bytes Count</td><td>1Byte</td><td>2 x N*</td></tr><tr><td>Registers Value</td><td>N* x 2 Bytes</td><td>value</td></tr></tbody></table><ul><li>Request OK</li></ul><table><thead><tr><th></th><th>byte</th><th>Data</th></tr></thead><tbody><tr><td>Function Code</td><td>1 byte</td><td>0x10</td></tr><tr><td>Starting Addresse</td><td>2 bytes</td><td>0x0000 to 0xffff</td></tr><tr><td>Quatity of Register</td><td>2 bytes</td><td>1 to 123(0x7b)</td></tr><tr><td>*N = Quantity of Registers</td><td></td><td></td></tr></tbody></table><ul><li>Request not OK</li></ul><table><thead><tr><th></th><th>byte</th><th>Data</th></tr></thead><tbody><tr><td>Error Code</td><td>1 byte</td><td>0x90</td></tr><tr><td>Exception Code</td><td>1 byte</td><td>0x01 ~ 0x06</td></tr></tbody></table><ul><li>example</li></ul><h2 id="packet-test" tabindex="-1">Packet Test <a class="header-anchor" href="#packet-test" aria-label="Permalink to &quot;Packet Test&quot;">​</a></h2>',36))])}const P=u(f,[["render",y]]);export{m as __pageData,P as default};
