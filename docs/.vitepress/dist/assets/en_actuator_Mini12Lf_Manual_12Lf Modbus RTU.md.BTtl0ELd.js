import{_ as d,c as e,o as r,ag as a}from"./chunks/framework.Bw-5EFTY.js";const i="/assets/packetDescription.C0Eykc0N.png",y=JSON.parse('{"title":"소개","description":"","frontmatter":{},"headers":[],"relativePath":"en/actuator/Mini12Lf/Manual/12Lf Modbus RTU.md","filePath":"en/actuator/Mini12Lf/Manual/12Lf Modbus RTU.md"}'),o={name:"en/actuator/Mini12Lf/Manual/12Lf Modbus RTU.md"};function l(h,t,n,s,u,b){return r(),e("div",null,t[0]||(t[0]=[a('<p>Modbus RTU Manual</p><h1 id="소개" tabindex="-1">소개 <a class="header-anchor" href="#소개" aria-label="Permalink to &quot;소개&quot;">​</a></h1><p>MODBUS 프로토콜은 산업용 프로토콜로 PLC통신 등에 주로 사용되는 표준이 되는 프로토콜입니다. 주로 사용하는 방식은 RTU방식과 ASCII방식이 주로 사용되고, 요즘에는 TCP방식도 나와있습니다.</p><p>1979년부터 업계의 사실상 직렬 표준인 MODBUS는 수 백만 개의 자동화 장치가 지속적으로 통신할 수 있도록 지원하고 있습니다. MODBUS는 요청/응답 프로토콜이며 기능 코드별로 지정된 서비스를 제공합니다. 프레임의 구성은 Application Data Unit인 ADU와 Protocol Data Unit인 PDU로 구성되어 있습니다.</p><h1 id="_1-프레임-구조" tabindex="-1">1 프레임 구조 <a class="header-anchor" href="#_1-프레임-구조" aria-label="Permalink to &quot;1 프레임 구조&quot;">​</a></h1><h2 id="_1-1-packet-discription" tabindex="-1">1.1 Packet Discription <a class="header-anchor" href="#_1-1-packet-discription" aria-label="Permalink to &quot;1.1 Packet Discription&quot;">​</a></h2><p>mightyZAP은 MODBUS-RTU 프로토콜 내용을 준수합니다.<br> 본 매뉴얼에 나오지 않은 사항들은 아래의 관련 표준 문서를 참조하여 주시기 바랍니다. ()</p><h3 id="_1-1-1-packet-structure" tabindex="-1">1.1.1 Packet Structure <a class="header-anchor" href="#_1-1-1-packet-structure" aria-label="Permalink to &quot;1.1.1 Packet Structure&quot;">​</a></h3><p>MODBUS-RTU 프로토콜의 최대 송수신 패킷 길이는 256 Byte 입니다. 따라서 송수신 패킷의 총 길이가 256Byte 를 넘기지 않도록 주의하여 주십시오.<br> MODBUS-RTU 통신 Mode 는 Packet 을 구분하기 위해서 아래 그림과 같이 시작과 끝 사이에 최소 3.5 Char 이상의 이 필요합니다.</p><p><img src="'+i+'" alt="packet Description"></p><ul><li>송신 패킷 구조</li></ul><table><thead><tr><th></th><th>Additional Address</th><th>Fucntion code</th><th colspan="3">Data</th><th>Error Check</th><th></th></tr></thead><tbody><tr><td>byte</td><td>0</td><td>1</td><td>2</td><td>.</td><td>.</td><td>n-1</td><td>n</td></tr><tr><td></td><td>mightyZAP ID</td><td>Function</td><td>Data</td><td>.</td><td>.</td><td>CRC(MSB)</td><td>CRC(LSB)</td></tr></tbody></table><ul><li>수신 패킷 구조 [정상 응담]</li></ul><table><thead><tr><th></th><th>Additional Address</th><th>Fucntion code</th><th colspan="3">Data</th><th colspan="2">Error Check</th></tr></thead><tbody><tr><td>byte</td><td>0</td><td>1</td><td>2</td><td>.</td><td>.</td><td>n-1</td><td>n</td></tr><tr><td></td><td>mightyZAP ID</td><td>Function</td><td>Data</td><td>.</td><td>.</td><td>CRC(MSB)</td><td>CRC(LSB)</td></tr></tbody></table><p>[비 정상 응답]</p><table><thead><tr><th></th><th>Additional Address</th><th>Fucntion code</th><th>Data</th><th>Error Check</th><th></th></tr></thead><tbody><tr><td>byte</td><td>0</td><td>1</td><td>2</td><td>n-1</td><td>n</td></tr><tr><td></td><td>mightyZAP ID</td><td>Function + 0x80</td><td>Exception code</td><td>CRC(MSB)</td><td>CRC(LSB)</td></tr></tbody></table><h3 id="_1-1-2-packet-element-설명" tabindex="-1">1.1.2 Packet Element 설명 <a class="header-anchor" href="#_1-1-2-packet-element-설명" aria-label="Permalink to &quot;1.1.2 Packet Element 설명&quot;">​</a></h3><ul><li>Node ID <ul><li>mightyZAP의 IDF로 다중 연결 방식으로 Daisy Chain 연결 지원을 위한 식별자 입니다.</li><li>ID가 &#39;0&#39;일 경우 Broadcasting ID로 동작합니다.</li></ul></li><li>Function Code <ul><li>mightyZAP에서 지원하는 Modbus-RTU 표준 Function code는 다음과 같습니다.</li></ul></li></ul><table><thead><tr><th>Function</th><th>Code</th><th>Description</th></tr></thead><tbody><tr><td>Read Holding Register</td><td>0x03</td><td>mightyZAP의 Data를 읽어오기</td></tr><tr><td>Write Single Register</td><td>0x06</td><td>mightyZAP의 특정 주소에 Data값을 Setting 하기</td></tr><tr><td>Write Multiple Register</td><td>0x10</td><td>mightyZAP의 연속된 주소에 Data값을 Setting 하기</td></tr><tr><td>SP Function code</td><td>0xxx</td><td>해당 모델 사용자 매뉴얼을 참조하여주시기 바랍니다.</td></tr></tbody></table><ul><li>Data 송신 : Read Register 명령의 경우 Modbus 주소, 레지스터 개수, Byte 개수 등을 지정하게 되며, Write Register 명령의 경우 Modbus 주소, Byte 개수, 설정 할 값 등을 지정하게 됩니다.<br> 수신: Read Register 명령의 경우, 정상응답은 Node ID 와 Function Code 가 송신 때와 동일한 값으로 수신되며, Data 는 송신 때 보낸 Register 순서에 따라 각 Register 의 값이 수신됩니다.</li></ul><p>Write Single Register 명령의 경우, 송신 때와 동일한 데이터가 수신됩니다. Write Multi Register 의 경우에는 Write Multi Register 명령으로 데이터를 쓰고자 한 Register 의 시작 주소와 Register 개수가 수신됩니다.</p><p>이상응답의 경우에는 Node ID, Error Code, Exception Code 로 구성되며, 이상응답의 패킷 구조는 Function Code 와 관계없이 모두 동일합니다.</p><ul><li><p>CRC 16 비트 CRC 값을 입력합니다. 구성은 MSB/LSB 로 나누어 각각 1Byte 씩 전송합니다.</p></li><li><p>Exception Code mightyZAP에서 지원하는 모든 Function Code 의 이상 응답에 대한 Exception Code 는 아래와 같이 정의되어 있습니다.</p></li></ul><table><thead><tr><th>Exception Code</th><th></th><th>Description</th></tr></thead><tbody><tr><td>0x01</td><td>Illegal Function</td><td>지원하지 않는 Function Code</td></tr><tr><td>0x02</td><td>Illegal Data Address</td><td>잘못된 레지스터 주소</td></tr><tr><td>0x03</td><td>Illegal Data Value</td><td>잘못된 데이터 값</td></tr><tr><td>0x04</td><td>Slave Device Failure</td><td>장치 고장, 파라미터 설정값 이상(ready)</td></tr><tr><td>0x05</td><td>Acknowledge</td><td>데이터가 준비되지 않은 상태(ready)</td></tr><tr><td>0x06</td><td>Slave Device Busy</td><td>파라미터 잠금 상태</td></tr></tbody></table><h2 id="프로토콜-function-code-설명" tabindex="-1">프로토콜 Function Code 설명 <a class="header-anchor" href="#프로토콜-function-code-설명" aria-label="Permalink to &quot;프로토콜 Function Code 설명&quot;">​</a></h2><h3 id="read-holding-register" tabindex="-1">Read Holding Register <a class="header-anchor" href="#read-holding-register" aria-label="Permalink to &quot;Read Holding Register&quot;">​</a></h3><p>단일 레지스터(16bit 데이터) 및 연속된 레지스터 블록(16bit 데이터 단위)의 값을 읽습니다.</p><ul><li>Request</li></ul><table><thead><tr><th></th><th>byte</th><th>Data</th></tr></thead><tbody><tr><td>Function Code</td><td>1 byte</td><td>0x03</td></tr><tr><td>Starting Addresse</td><td>2 byte</td><td>0x0000 to 0xffff</td></tr><tr><td>Quatity of Register</td><td>2 bytes</td><td>1 to 125(0x7d)</td></tr></tbody></table><ul><li>Request OK</li></ul><table><thead><tr><th></th><th>byte</th><th>Data</th></tr></thead><tbody><tr><td>Function Code</td><td>1 byte</td><td>0x03</td></tr><tr><td>Starting Addresse</td><td>2 byte</td><td>2 x N*</td></tr><tr><td>Quatity of Register</td><td>N* x 2 bytes</td><td></td></tr><tr><td>*N = Quantity of Registers</td><td></td><td></td></tr></tbody></table><ul><li>Request not OK</li></ul><table><thead><tr><th></th><th>byte</th><th>Data</th></tr></thead><tbody><tr><td>Error Code</td><td>1 byte</td><td>0x83</td></tr><tr><td>Exception Code</td><td>1 byte</td><td>0x01 ~ 0x06</td></tr></tbody></table><ul><li>example</li></ul><h3 id="write-sing-register" tabindex="-1">Write Sing Register <a class="header-anchor" href="#write-sing-register" aria-label="Permalink to &quot;Write Sing Register&quot;">​</a></h3><p>단일레지스터(16bit 데이터)에 값을 씁니다.</p><ul><li>Request</li></ul><table><thead><tr><th></th><th>byte</th><th>Data</th></tr></thead><tbody><tr><td>Function Code</td><td>1 byte</td><td>0x06</td></tr><tr><td>Starting Addresse</td><td>2 bytes</td><td>0x0000 to 0xffff</td></tr><tr><td>Quatity of Register</td><td>2 bytes</td><td>0x0000 to 0xffff</td></tr></tbody></table><ul><li>Request OK</li></ul><table><thead><tr><th></th><th>byte</th><th>Data</th></tr></thead><tbody><tr><td>Function Code</td><td>1 byte</td><td>0x03</td></tr><tr><td>Starting Addresse</td><td>2 bytes</td><td>0x0000 to 0xffff</td></tr><tr><td>Quatity of Register</td><td>2 bytes</td><td>0x0000 to 0xffff</td></tr><tr><td>*N = Quantity of Registers</td><td></td><td></td></tr></tbody></table><ul><li>Request not OK</li></ul><table><thead><tr><th></th><th>byte</th><th>Data</th></tr></thead><tbody><tr><td>Error Code</td><td>1 byte</td><td>0x86</td></tr><tr><td>Exception Code</td><td>1 byte</td><td>0x01 ~ 0x06</td></tr></tbody></table><ul><li>example</li></ul><h3 id="write-multi-register-0x10" tabindex="-1">Write Multi Register(0x10) <a class="header-anchor" href="#write-multi-register-0x10" aria-label="Permalink to &quot;Write Multi Register(0x10)&quot;">​</a></h3><p>연속된 레지스터 블록(16bit 데이터 단위)에 값을 씁니다.</p><ul><li>Request</li></ul><table><thead><tr><th></th><th>byte</th><th>Data</th></tr></thead><tbody><tr><td>Function Code</td><td>1 byte</td><td>0x06</td></tr><tr><td>Starting Addresse</td><td>2 bytes</td><td>0x0000 to 0xffff</td></tr><tr><td>Quatity of Register</td><td>2 bytes</td><td>0x0000 to 0xffff</td></tr><tr><td>Bytes Count</td><td>1Byte</td><td>2 x N*</td></tr><tr><td>Registers Value</td><td>N* x 2 Bytes</td><td>value</td></tr></tbody></table><ul><li>Request OK</li></ul><table><thead><tr><th></th><th>byte</th><th>Data</th></tr></thead><tbody><tr><td>Function Code</td><td>1 byte</td><td>0x10</td></tr><tr><td>Starting Addresse</td><td>2 bytes</td><td>0x0000 to 0xffff</td></tr><tr><td>Quatity of Register</td><td>2 bytes</td><td>1 to 123(0x7b)</td></tr><tr><td>*N = Quantity of Registers</td><td></td><td></td></tr></tbody></table><ul><li>Request not OK</li></ul><table><thead><tr><th></th><th>byte</th><th>Data</th></tr></thead><tbody><tr><td>Error Code</td><td>1 byte</td><td>0x90</td></tr><tr><td>Exception Code</td><td>1 byte</td><td>0x01 ~ 0x06</td></tr></tbody></table><ul><li>example</li></ul>',52)]))}const x=d(o,[["render",l]]);export{y as __pageData,x as default};
